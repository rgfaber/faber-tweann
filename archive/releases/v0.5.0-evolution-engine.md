# v0.5.0 - Evolution Engine

## Overview

This release refactors the genetic mutation operators and evolution mechanisms. The focus is on consolidating duplicate code, documenting mutation strategies, and improving the modularity of `genome_mutator.erl`.

**Phase**: Structural
**Duration**: 2 weeks
**Prerequisites**: v0.4.0 (cortex, exoself refactored)

## Objectives

1. Consolidate duplicate mutation operator functions
2. Extract weight perturbation to utility module
3. Document mutation strategies with mathematical definitions
4. Fix typo in constant name
5. Break down large mutation functions

## Modules to Refactor

### 1. genome_mutator.erl (1,424 lines)

**Analysis Reference**: Section 3.4 of DXNN2_CODEBASE_ANALYSIS.md (lines 341-413)

**Issues to Address**:
- Duplicate mutation functions (lines 156-201)
- Typo "PARAMTERS" (line 26)
- Magic numbers without justification
- Large add_neuron function (~100 lines)
- Roulette wheel selection not extracted
- Weight perturbation duplicated 3+ times

**Tasks**:

1. **Fix typo in constant** (line 26)
   ```erlang
   %% Before
   -define(SEARCH_PARAMTERS_MUTATION_PROBABILITY, 0).

   %% After
   -define(SEARCH_PARAMETERS_MUTATION_PROBABILITY, 0).
   ```

2. **Consolidate duplicate mutation operator functions** (lines 156-201)
   ```erlang
   %% Before: 4 nearly identical functions
   mutate_tuning_selection(AgentId) -> ...
   mutate_tuning_annealing(AgentId) -> ...
   mutate_tot_topological_mutations(AgentId) -> ...
   mutate_heredity_type(AgentId) -> ...

   %% After: single parametric function
   -spec mutate_agent_parameter(agent_id(), field_name(), constraint_field()) ->
       ok | {error, no_alternatives}.

   mutate_agent_parameter(AgentId, FieldName, ConstraintField) ->
       A = genotype:read({agent, AgentId}),
       Constraint = A#agent.constraint,
       CurrentValue = get_agent_field(A, FieldName),
       AvailableValues = get_constraint_field(Constraint, ConstraintField) -- [CurrentValue],
       case AvailableValues of
           [] ->
               {error, no_alternatives};
           Values ->
               NewValue = random_select(Values),
               UpdatedAgent = set_agent_field(A, FieldName, NewValue),
               genotype:write(UpdatedAgent),
               ok
       end.

   %% Wrapper functions for backward compatibility
   mutate_tuning_selection(AgentId) ->
       mutate_agent_parameter(AgentId, tuning_selection_f, tuning_selection_fs).
   ```

3. **Extract roulette wheel selection to utility module**
   ```erlang
   %% Create new module: selection_utils.erl

   -module(selection_utils).
   -export([roulette_wheel/1, random_select/1, weighted_select/2]).

   %% @doc Roulette wheel selection based on weights
   %%
   %% Selects an element with probability proportional to its weight.
   %% Higher weight = higher probability of selection.
   %%
   %% Algorithm:
   %% 1. Calculate total weight
   %% 2. Generate random value in [0, total)
   %% 3. Accumulate weights until random value exceeded
   %%
   %% @param WeightedItems list of {Item, Weight} tuples
   %% @returns selected Item
   -spec roulette_wheel([{term(), number()}]) -> term().
   roulette_wheel(WeightedItems) ->
       TotalWeight = lists:sum([W || {_, W} <- WeightedItems]),
       RandomValue = rand:uniform() * TotalWeight,
       select_by_accumulated_weight(WeightedItems, RandomValue, 0).

   select_by_accumulated_weight([{Item, Weight} | Rest], Target, Acc) ->
       NewAcc = Acc + Weight,
       case NewAcc >= Target of
           true -> Item;
           false -> select_by_accumulated_weight(Rest, Target, NewAcc)
       end;
   select_by_accumulated_weight([], _, _) ->
       error({selection_failed, empty_list}).
   ```

4. **Extract weight perturbation to utility module**
   ```erlang
   %% Create new module: perturbation_utils.erl

   -module(perturbation_utils).
   -export([perturb_weight/2, perturb_weights/2, perturb_plasticity_params/2]).

   %% @doc Perturb a single weight with momentum
   %%
   %% Uses momentum-based perturbation:
   %% DW_new = random_noise * spread + DW_old * 0.5
   %% W_new = saturate(W + DW_new)
   %%
   %% The 0.5 momentum factor provides smooth weight trajectories
   %% during evolution.
   -spec perturb_weight(weight_spec(), perturbation_range()) -> weight_spec().
   perturb_weight({W, DW, LP, LPs}, Spread) ->
       NewDW = (rand:uniform() - 0.5) * Spread + DW * 0.5,
       NewW = functions:sat(W + NewDW, ?SAT_LIMIT),
       {NewW, NewDW, LP, LPs}.

   %% @doc Perturb list of weight specs
   -spec perturb_weights([weight_spec()], perturbation_range()) -> [weight_spec()].
   perturb_weights(WeightSpecs, Spread) ->
       [perturb_weight(WS, Spread) || WS <- WeightSpecs].
   ```

5. **Document magic numbers** (lines 24-25)
   ```erlang
   %% @doc Delta multiplier for weight perturbation
   %%
   %% Using 2*pi (~6.28) as base perturbation range provides
   %% sufficient exploration while maintaining stability.
   %% This value was empirically determined.
   -define(DELTA_MULTIPLIER, math:pi() * 2).

   %% @doc Maximum weight value (saturation limit)
   %%
   %% Weights are clamped to [-SAT_LIMIT, SAT_LIMIT] to prevent
   %% numerical overflow and maintain network stability.
   -define(SAT_LIMIT, math:pi() * 10).
   ```

6. **Break down add_neuron function**
   ```erlang
   %% Before: ~100 line monolithic function

   %% After: decomposed into steps
   add_neuron(AgentId) ->
       Agent = genotype:read({agent, AgentId}),
       case find_splittable_link(Agent) of
           {error, no_links} ->
               {error, cannot_add_neuron};
           {FromId, ToId, Weight} ->
               NewNeuronId = create_neuron_id(Agent),
               NewNeuron = create_neuron(NewNeuronId, Agent, FromId, ToId),
               update_source_neuron(FromId, NewNeuronId, Agent),
               update_target_neuron(ToId, NewNeuronId, Weight, Agent),
               genotype:write(NewNeuron),
               update_agent_neuron_ids(AgentId, NewNeuronId),
               ok
       end.

   %% Helper functions
   -spec find_splittable_link(agent()) -> {element_id(), element_id(), weight()} |
                                          {error, no_links}.
   -spec create_neuron_id(agent()) -> neuron_id().
   -spec create_neuron(neuron_id(), agent(), element_id(), element_id()) -> neuron().
   ```

7. **Add comprehensive module documentation**
   ```erlang
   %% @module genome_mutator
   %% @doc Genetic mutation operators for neural network evolution
   %%
   %% This module provides mutation operators that modify network genotypes
   %% to explore the solution space. Mutations are categorized as:
   %%
   %% == Topological Mutations ==
   %% Modify network structure:
   %% - add_neuron: Insert neuron into existing connection
   %% - add_link: Connect two unconnected elements
   %% - splice: Split connection with new neuron
   %%
   %% == Parametric Mutations ==
   %% Modify values without changing structure:
   %% - mutate_weights: Perturb synaptic weights
   %% - mutate_af: Change activation function
   %% - mutate_plasticity: Modify learning parameters
   %%
   %% == Evolutionary Strategy Mutations ==
   %% Meta-evolution of search parameters:
   %% - mutate_tuning_selection: Change weight selection strategy
   %% - mutate_annealing: Modify simulated annealing schedule
   %%
   %% == Mutation Selection ==
   %% Mutations are selected using roulette wheel selection
   %% weighted by mutation probabilities from the constraint.
   ```

### 2. Create utility modules

**selection_utils.erl**:
- Roulette wheel selection
- Random selection
- Tournament selection (if needed)

**perturbation_utils.erl**:
- Weight perturbation
- Plasticity parameter perturbation
- Saturation functions

## Tests to Write

### genome_mutator_test.erl

```erlang
-module(genome_mutator_test).
-include_lib("eunit/include/eunit.hrl").
-include("records.hrl").

%% ============================================================================
%% Mutation operator selection tests
%% ============================================================================

select_mutation_operator_test() ->
    %% Test that mutation selection returns valid operators
    Constraint = test_helpers:create_test_constraint(),
    Operator = genome_mutator:select_mutation_operator(Constraint),
    ?assert(is_atom(Operator)).

%% ============================================================================
%% Parametric mutation tests
%% ============================================================================

mutate_agent_parameter_test() ->
    %% Setup test agent with constraint
    {ok, AgentId} = test_helpers:create_test_agent_in_db(),

    %% Mutate tuning selection
    Result = genome_mutator:mutate_agent_parameter(
        AgentId,
        tuning_selection_f,
        tuning_selection_fs
    ),

    case Result of
        ok ->
            %% Verify field changed
            Agent = genotype:read({agent, AgentId}),
            ?assert(is_atom(Agent#agent.tuning_selection_f));
        {error, no_alternatives} ->
            %% Valid when only one option
            ok
    end,

    test_helpers:cleanup_test_agent(AgentId).

mutate_tuning_selection_backward_compat_test() ->
    %% Ensure wrapper function works
    {ok, AgentId} = test_helpers:create_test_agent_in_db(),
    _Result = genome_mutator:mutate_tuning_selection(AgentId),
    test_helpers:cleanup_test_agent(AgentId).

%% ============================================================================
%% Topological mutation tests
%% ============================================================================

add_neuron_test() ->
    {ok, AgentId} = test_helpers:create_test_agent_in_db(),

    %% Get initial neuron count
    Agent1 = genotype:read({agent, AgentId}),
    InitialCount = length(Agent1#agent.neuron_ids),

    %% Add neuron
    Result = genome_mutator:add_neuron(AgentId),

    case Result of
        ok ->
            Agent2 = genotype:read({agent, AgentId}),
            NewCount = length(Agent2#agent.neuron_ids),
            ?assertEqual(InitialCount + 1, NewCount);
        {error, cannot_add_neuron} ->
            %% Valid for networks without splittable links
            ok
    end,

    test_helpers:cleanup_test_agent(AgentId).

add_link_test() ->
    {ok, AgentId} = test_helpers:create_test_agent_in_db(),

    Result = genome_mutator:add_link(AgentId),

    case Result of
        ok -> ok;
        {error, _Reason} -> ok  % Valid for fully connected
    end,

    test_helpers:cleanup_test_agent(AgentId).

%% ============================================================================
%% Weight mutation tests
%% ============================================================================

mutate_weights_test() ->
    {ok, AgentId} = test_helpers:create_test_agent_in_db(),

    %% Get initial weights
    Neuron1 = test_helpers:get_first_neuron(AgentId),
    InitialWeights = Neuron1#neuron.input_idps,

    %% Mutate weights
    genome_mutator:mutate_weights(AgentId),

    %% Verify weights changed
    Neuron2 = genotype:read({neuron, Neuron1#neuron.id}),
    NewWeights = Neuron2#neuron.input_idps,

    ?assertNotEqual(InitialWeights, NewWeights),

    test_helpers:cleanup_test_agent(AgentId).
```

### selection_utils_test.erl

```erlang
-module(selection_utils_test).
-include_lib("eunit/include/eunit.hrl").

%% ============================================================================
%% Roulette wheel tests
%% ============================================================================

roulette_wheel_single_item_test() ->
    Items = [{item1, 1.0}],
    Result = selection_utils:roulette_wheel(Items),
    ?assertEqual(item1, Result).

roulette_wheel_selects_higher_weight_more_often_test() ->
    %% Heavy item should be selected more often
    Items = [{light, 1.0}, {heavy, 99.0}],

    %% Run many selections
    Selections = [selection_utils:roulette_wheel(Items) || _ <- lists:seq(1, 1000)],

    HeavyCount = length([S || S <- Selections, S == heavy]),
    LightCount = length([S || S <- Selections, S == light]),

    %% Heavy should be selected approximately 99x more often
    ?assert(HeavyCount > LightCount * 10).

roulette_wheel_empty_list_test() ->
    ?assertError({selection_failed, empty_list}, selection_utils:roulette_wheel([])).

%% ============================================================================
%% Random select tests
%% ============================================================================

random_select_single_test() ->
    ?assertEqual(item1, selection_utils:random_select([item1])).

random_select_returns_list_element_test() ->
    Items = [a, b, c, d, e],
    Result = selection_utils:random_select(Items),
    ?assert(lists:member(Result, Items)).
```

### perturbation_utils_test.erl

```erlang
-module(perturbation_utils_test).
-include_lib("eunit/include/eunit.hrl").

%% ============================================================================
%% Weight perturbation tests
%% ============================================================================

perturb_weight_changes_value_test() ->
    Original = {0.5, 0.0, 0.1, []},
    Spread = 0.5,
    {NewW, NewDW, LP, LPs} = perturbation_utils:perturb_weight(Original, Spread),

    %% Weight should change (with very high probability)
    ?assert(NewW /= 0.5 orelse NewDW /= 0.0),
    ?assertEqual(0.1, LP),
    ?assertEqual([], LPs).

perturb_weight_within_saturation_test() ->
    %% Even large perturbations should be saturated
    Original = {10.0, 0.0, 0.1, []},
    Spread = 100.0,
    {NewW, _, _, _} = perturbation_utils:perturb_weight(Original, Spread),

    ?assert(abs(NewW) =< ?SAT_LIMIT).

perturb_weight_momentum_test() ->
    %% Previous delta weight should influence new delta
    WithMomentum = {0.5, 1.0, 0.1, []},  % Large previous DW
    WithoutMomentum = {0.5, 0.0, 0.1, []},
    Spread = 0.1,

    %% Run multiple times and average
    Results1 = [begin
        {_, DW, _, _} = perturbation_utils:perturb_weight(WithMomentum, Spread),
        DW
    end || _ <- lists:seq(1, 100)],

    Results2 = [begin
        {_, DW, _, _} = perturbation_utils:perturb_weight(WithoutMomentum, Spread),
        DW
    end || _ <- lists:seq(1, 100)],

    Avg1 = lists:sum(Results1) / 100,
    Avg2 = lists:sum(Results2) / 100,

    %% With momentum should have higher average DW
    ?assert(Avg1 > Avg2).

%% ============================================================================
%% Batch perturbation tests
%% ============================================================================

perturb_weights_all_changed_test() ->
    Weights = [
        {0.5, 0.0, 0.1, []},
        {0.3, 0.0, 0.1, []},
        {0.7, 0.0, 0.1, []}
    ],
    Spread = 0.5,

    Perturbed = perturbation_utils:perturb_weights(Weights, Spread),

    ?assertEqual(length(Weights), length(Perturbed)).

perturb_weights_empty_test() ->
    ?assertEqual([], perturbation_utils:perturb_weights([], 0.5)).
```

## Documentation Requirements

### Required Documentation

1. **genome_mutator.erl**
   - Module overview with mutation categories
   - Each mutation operator documented
   - Mutation selection strategy
   - Mathematical definitions where applicable

2. **selection_utils.erl**
   - Roulette wheel algorithm
   - Probability calculations

3. **perturbation_utils.erl**
   - Momentum calculation
   - Saturation behavior

### Documentation Checklist

- [ ] All mutation operators have @doc
- [ ] Roulette wheel algorithm explained
- [ ] Weight perturbation formula documented
- [ ] Magic numbers justified
- [ ] All function specs complete

## Quality Gates

### v0.5.0 Acceptance Criteria

1. **Bug Fixes**
   - [ ] "PARAMTERS" typo fixed
   - [ ] Test verifies correct spelling

2. **Code Consolidation**
   - [ ] 4 duplicate functions consolidated to 1
   - [ ] Weight perturbation in single location
   - [ ] Roulette selection extracted

3. **Function Decomposition**
   - [ ] add_neuron broken into steps
   - [ ] No function exceeds 50 lines
   - [ ] Helper functions documented

4. **Test Coverage**
   - [ ] genome_mutator.erl: 90%+ coverage
   - [ ] selection_utils.erl: 100% coverage
   - [ ] perturbation_utils.erl: 100% coverage

5. **Static Analysis**
   - [ ] Zero dialyzer warnings

## Known Limitations

- Complex mutations (splice, substrate) simplified
- Not all edge cases tested
- Performance not optimized

## Next Steps

After v0.5.0 completion:

1. **v0.6.0** will refactor `population_monitor.erl`
2. Evolution engine complete
3. Population management begins

## Implementation Notes

### Mutation Operator Pattern

All topological mutations follow this pattern:

```erlang
mutation_operator(AgentId) ->
    %% 1. Read current state
    Agent = genotype:read({agent, AgentId}),

    %% 2. Find candidates for mutation
    case find_candidates(Agent) of
        [] ->
            {error, no_candidates};
        Candidates ->
            %% 3. Select random candidate
            Selected = selection_utils:random_select(Candidates),

            %% 4. Apply mutation
            apply_mutation(Agent, Selected),

            %% 5. Update agent
            update_agent(AgentId),
            ok
    end.
```

### Mutation Selection Process

```erlang
apply_mutations(AgentId, Count) ->
    Constraint = get_constraint(AgentId),
    MutationOperators = Constraint#constraint.mutation_operators,

    lists:foreach(
        fun(_) ->
            Operator = selection_utils:roulette_wheel(MutationOperators),
            apply_mutation(AgentId, Operator)
        end,
        lists:seq(1, Count)
    ).
```

## Dependencies

### External Dependencies

- Mnesia for genotype storage

### Internal Dependencies

- v0.4.0: exoself, cortex
- v0.3.0: neuron records
- v0.1.0: types, test infrastructure

## Effort Estimate

| Task | Estimate |
|------|----------|
| Consolidate mutations | 1.5 days |
| Extract utilities | 1.5 days |
| Decompose add_neuron | 1 day |
| Mutation tests | 2 days |
| Utility tests | 1.5 days |
| Documentation | 1.5 days |
| Fix typo | 0.25 days |
| **Total** | **9-10 days** |

## Risks

| Risk | Mitigation |
|------|------------|
| Breaking mutation behavior | Tests before consolidation |
| Utility API design issues | Review before implementation |
| Complex mutations fail | Test each mutation type |

---

**Version**: 0.5.0
**Phase**: Structural
**Status**: Planned
